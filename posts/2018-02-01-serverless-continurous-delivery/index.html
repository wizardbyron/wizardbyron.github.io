<!doctype html><html lang=zh class=dark><head>
<meta charset=utf-8>
<meta http-equiv=content-language content="zh">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="ie=edge">
<title>Serverless 风格的微服务的持续交付 &#183; 顾宇的博客</title>
<meta name=title content="Serverless 风格的微服务的持续交付 &#183; 顾宇的博客">
<meta name=description content>
<link rel=canonical href=https://wwww.guyu.me/posts/2018-02-01-serverless-continurous-delivery/>
<link type=text/css rel=stylesheet href=/css/schemes/slate.min.1fa9cfe6ea431f51b6669ad59d531a840711f25edf67f90d0227253371e1da49fdcc25506150e39fb99ac2c95a6012b2c4bbdd6c41b841b186419cbd7e115768.css integrity="sha512-H6nP5upDH1G2ZprVnVMahAcR8l7fZ/kNAiclM3Hh2kn9zCVQYVDjn7mawslaYBKyxLvdbEG4QbGGQZy9fhFXaA==">
<link type=text/css rel=stylesheet href=/css/compiled/main.min.4076b9cf114dd23cca017f3365e2205a4c9a4b2c0ef4193ccd08883f76e554aa40f674a8f6e77a1b2895be0975ba8e019b0c59996c2eea32e4970ca4d5221653.css integrity="sha512-QHa5zxFN0jzKAX8zZeIgWkyaSywO9Bk8zQiIP3blVKpA9nSo9ud6GyiVvgl1uo4BmwxZmWwu6jLklwyk1SIWUw==">
<script>function loadPreferredAppearance(){localStorage.preferredAppearance==="dark"||!("preferredAppearance"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")}function setPreferredAppearance(a){a=="default"?localStorage.removeItem("preferredAppearance"):localStorage.preferredAppearance=a,loadPreferredAppearance()}loadPreferredAppearance(),window.matchMedia("(prefers-color-scheme: dark)").addListener(loadPreferredAppearance)</script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/site.webmanifest>
<meta property="og:title" content="Serverless 风格的微服务的持续交付">
<meta property="og:description" content="“Serverless 风格微服务的持续交付（上）：架构案例”中，我们介绍了一个无服务器风格的微服务的架构案例。这个案例中混合了各种风格的微服务
架构图如下：
在这个架构中，我们采用了前后端分离的技术。我们把 HTML，JS， CSS 等静态内容部署在 S3 上，并通过 CloudFront 作为 CDN 构成了整个架构的前端部分。我们把 Amazon API Gateway 作为后端的整体接口连接后端的各种风格的微服务，无论是运行在 Lambda 上的函数，还是运行在 EC2 上的 Java 微服务，他们整体构成了这个应用的后端部分。
从这个架构图上我们可以明显的看到 前端（Frontend）和后端（Backend）的区分。
持续部署流水线的设计和实现 # 任何 DevOps 部署流水线都可以分为三个阶段：待测试，待发布，已发布。
由于我们的架构是前后端分离的，因此我们为前端和后端分别构造了两条流水线，使得前后端开发可以独立。如下图所示：
在这种情况下，前端团队和后端团队是两个不同的团队，可以独立开发和部署，但在发布的时候则有些不同。由于用户是最后感知功能变化的。因此，为了避免界面报错找不到接口，在新增功能的场景下，后端先发布，前端后发布。在删除功能的场景下，前端先发布，后端后发布。
我们采用 Jenkins 构建我们的流水线，Jenkins 中已经含有足够的 AWS 插件可以帮助我们完成整个端到端的持续交付流水线。
前端流水线 # 前端持续交付流水线如下所示：
前端流水线的各步骤过程如下：
 我们采用 BDD/ATDD 的方式进行前端开发。用 NightWatch.JS 框架做 端到端的测试，mocha 和 chai 用于做某些逻辑的验证。 我们采用单代码库主干（develop 分支）进行开发，用 master 分支作为生产环境的部署。生产环境的发布则是通过 Pull Request 合并的。在合并前，我们会合并提交。 前端采用 Webpack 进行构建，形成前端的交付产物。在构建之前，先进行一次全局测试。 由于 S3 不光可以作为对象存储服务，也可以作为一个高可用、高性能而且成本低廉的静态 Web 服务器。所以我们的前端静态内容存储在 S3 上。每一次部署都会在 S3 上以 build 号形成一个新的目录，然后把 Webpack 构建出来的文件存储进去。 我们采用 Cloudfront 作为 CDN，这样可以和 S3 相互集成。只需要把 S3 作为 CDN 的源，在发布时修改对应发布的目录就可以了。  由于我们做到了前后端分离。因此前端的数据和业务请求会通过 Ajax 的方式请求后端的 Rest API，而这个 Rest API 是由 Amazon API Gateway 通过 Swagger 配置生成的。前端只需要知道 这个 API Gateway，而无需知道API Gateway 的对应实现。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://wwww.guyu.me/posts/2018-02-01-serverless-continurous-delivery/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-02-01T00:00:00+00:00">
<meta property="article:modified_time" content="2018-02-01T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Serverless 风格的微服务的持续交付">
<meta name=twitter:description content="“Serverless 风格微服务的持续交付（上）：架构案例”中，我们介绍了一个无服务器风格的微服务的架构案例。这个案例中混合了各种风格的微服务
架构图如下：
在这个架构中，我们采用了前后端分离的技术。我们把 HTML，JS， CSS 等静态内容部署在 S3 上，并通过 CloudFront 作为 CDN 构成了整个架构的前端部分。我们把 Amazon API Gateway 作为后端的整体接口连接后端的各种风格的微服务，无论是运行在 Lambda 上的函数，还是运行在 EC2 上的 Java 微服务，他们整体构成了这个应用的后端部分。
从这个架构图上我们可以明显的看到 前端（Frontend）和后端（Backend）的区分。
持续部署流水线的设计和实现 # 任何 DevOps 部署流水线都可以分为三个阶段：待测试，待发布，已发布。
由于我们的架构是前后端分离的，因此我们为前端和后端分别构造了两条流水线，使得前后端开发可以独立。如下图所示：
在这种情况下，前端团队和后端团队是两个不同的团队，可以独立开发和部署，但在发布的时候则有些不同。由于用户是最后感知功能变化的。因此，为了避免界面报错找不到接口，在新增功能的场景下，后端先发布，前端后发布。在删除功能的场景下，前端先发布，后端后发布。
我们采用 Jenkins 构建我们的流水线，Jenkins 中已经含有足够的 AWS 插件可以帮助我们完成整个端到端的持续交付流水线。
前端流水线 # 前端持续交付流水线如下所示：
前端流水线的各步骤过程如下：
 我们采用 BDD/ATDD 的方式进行前端开发。用 NightWatch.JS 框架做 端到端的测试，mocha 和 chai 用于做某些逻辑的验证。 我们采用单代码库主干（develop 分支）进行开发，用 master 分支作为生产环境的部署。生产环境的发布则是通过 Pull Request 合并的。在合并前，我们会合并提交。 前端采用 Webpack 进行构建，形成前端的交付产物。在构建之前，先进行一次全局测试。 由于 S3 不光可以作为对象存储服务，也可以作为一个高可用、高性能而且成本低廉的静态 Web 服务器。所以我们的前端静态内容存储在 S3 上。每一次部署都会在 S3 上以 build 号形成一个新的目录，然后把 Webpack 构建出来的文件存储进去。 我们采用 Cloudfront 作为 CDN，这样可以和 S3 相互集成。只需要把 S3 作为 CDN 的源，在发布时修改对应发布的目录就可以了。  由于我们做到了前后端分离。因此前端的数据和业务请求会通过 Ajax 的方式请求后端的 Rest API，而这个 Rest API 是由 Amazon API Gateway 通过 Swagger 配置生成的。前端只需要知道 这个 API Gateway，而无需知道API Gateway 的对应实现。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","articleSection":"Posts","name":"Serverless 风格的微服务的持续交付","headline":"Serverless 风格的微服务的持续交付","description":"“Serverless 风格微服务的持续交付（上）：架构案例”中，我们介绍了一个无服务器风格的微服务的架构案例。这个案例中混合了各种风格的微服务\n架构图如下：\n在这个架构中，我们采用了前后端分离的技术。我们把 HTML，JS， CSS 等静态内容部署在 S3 上，并通过 CloudFront 作为 CDN 构成了整个架构的前端部分。我们把 Amazon API Gateway 作为后端的整体接口连接后端的各种风格的微服务，无论是运行在 Lambda 上的函数，还是运行在 EC2 上的 Java 微服务，他们整体构成了这个应用的后端部分。\n从这个架构图上我们可以明显的看到 前端（Frontend）和后端（Backend）的区分。\n持续部署流水线的设计和实现 # 任何 DevOps 部署流水线都可以分为三个阶段：待测试，待发布，已发布。\n由于我们的架构是前后端分离的，因此我们为前端和后端分别构造了两条流水线，使得前后端开发可以独立。如下图所示：\n在这种情况下，前端团队和后端团队是两个不同的团队，可以独立开发和部署，但在发布的时候则有些不同。由于用户是最后感知功能变化的。因此，为了避免界面报错找不到接口，在新增功能的场景下，后端先发布，前端后发布。在删除功能的场景下，前端先发布，后端后发布。\n我们采用 Jenkins 构建我们的流水线，Jenkins 中已经含有足够的 AWS 插件可以帮助我们完成整个端到端的持续交付流水线。\n前端流水线 # 前端持续交付流水线如下所示：\n前端流水线的各步骤过程如下：\n 我们采用 BDD\/ATDD 的方式进行前端开发。用 NightWatch.JS 框架做 端到端的测试，mocha 和 chai 用于做某些逻辑的验证。 我们采用单代码库主干（develop 分支）进行开发，用 master 分支作为生产环境的部署。生产环境的发布则是通过 Pull Request 合并的。在合并前，我们会合并提交。 前端采用 Webpack 进行构建，形成前端的交付产物。在构建之前，先进行一次全局测试。 由于 S3 不光可以作为对象存储服务，也可以作为一个高可用、高性能而且成本低廉的静态 Web 服务器。所以我们的前端静态内容存储在 S3 上。每一次部署都会在 S3 上以 build 号形成一个新的目录，然后把 Webpack 构建出来的文件存储进去。 我们采用 Cloudfront 作为 CDN，这样可以和 S3 相互集成。只需要把 S3 作为 CDN 的源，在发布时修改对应发布的目录就可以了。  由于我们做到了前后端分离。因此前端的数据和业务请求会通过 Ajax 的方式请求后端的 Rest API，而这个 Rest API 是由 Amazon API Gateway 通过 Swagger 配置生成的。前端只需要知道 这个 API Gateway，而无需知道API Gateway 的对应实现。","inLanguage":"zh","author":{"@type":"Person","name":"顾宇"},"creator":{"@type":"Person","name":"顾宇"},"copyrightHolder":"顾宇","copyrightYear":"2018","dateCreated":"2018-02-01T00:00:00\u002b00:00","datePublished":"2018-02-01T00:00:00\u002b00:00","dateModified":"2018-02-01T00:00:00\u002b00:00","url":"https:\/\/wwww.guyu.me\/posts\/2018-02-01-serverless-continurous-delivery\/","wordCount":"398","keywords":["Serverless","Lambda","微服务","AWS","持续交付"]}</script>
<meta name=generator content="Hugo 0.90.1">
<meta name=author content="顾宇">
<link href=https://linkedin.com/in/wizardbyron rel=me>
<link href=https://github.com/wizardbyron rel=me>
</head>
<body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 bg-neutral text-neutral-900 sm:px-14 md:px-24 lg:px-32 dark:bg-neutral-800 dark:text-neutral max-w-7xl"><header class="flex justify-between py-6 font-semibold sm:items-center sm:py-10 text-neutral-800 dark:text-neutral">
<div>
<a class="hover:underline hover:underline-primary-500 hover:underline-thickness-bold hover:underline-offset-small" rel=me href=/>顾宇的博客</a>
</div>
<nav>
<ul class="flex flex-col list-none sm:flex-row">
<li class="mb-1 text-right sm:mb-0 sm:mr-7 sm:last:mr-0">
<a class="hover:underline hover:underline-primary-500 hover:underline-thickness-bold hover:underline-offset-small" href=/ title>主页</a>
</li>
<li class="mb-1 text-right sm:mb-0 sm:mr-7 sm:last:mr-0">
<a class="hover:underline hover:underline-primary-500 hover:underline-thickness-bold hover:underline-offset-small" href=/posts/ title=Posts>博客</a>
</li>
<li class="mb-1 text-right sm:mb-0 sm:mr-7 sm:last:mr-0">
<a class="hover:underline hover:underline-primary-500 hover:underline-thickness-bold hover:underline-offset-small" href=/categories/ title=Categories>分类</a>
</li>
<li class="mb-1 text-right sm:mb-0 sm:mr-7 sm:last:mr-0">
<a class="hover:underline hover:underline-primary-500 hover:underline-thickness-bold hover:underline-offset-small" href=/tags/ title=Tags>标签</a>
</li>
<li class="mb-1 text-right sm:mb-0 sm:mr-7 sm:last:mr-0">
<a class="hover:underline hover:underline-primary-500 hover:underline-thickness-bold hover:underline-offset-small" href=/about/ title=关于我>关于</a>
</li>
</ul>
</nav>
</header>
<main class=flex-grow>
<article class=max-w-prose>
<header>
<h1 class="mt-0 text-4xl font-extrabold text-neutral-800 dark:text-neutral">
Serverless 风格的微服务的持续交付
</h1>
<div class="mt-8 mb-12 text-base text-neutral-400 dark:text-neutral-500">
<div class="flex flex-row items-center">
<time datetime="2018-02-01 00:00:00 +0000 UTC">1 February 2018</time><span class="px-2 text-primary-500">&#183;</span>
<span class=mb-[2px]>
<a href=https://github.com/wizardbyron/wizardbyron.github.io/tree/main/content/posts/2018-02-01-serverless-continurous-delivery.md class="text-lg hover:text-primary-500" rel="noopener noreferrer" target=_blank title=编辑内容>
<span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg>
</span>
</a>
</span>
</div>
</div>
</header>
<section class="prose dark:prose-light">
<p>“Serverless 风格微服务的持续交付（上）：架构案例”中，我们介绍了一个无服务器风格的微服务的架构案例。这个案例中混合了各种风格的微服务</p>
<p>架构图如下：</p>
<p><img src=/img/post/20180201/ServerlessInAWS.jpg alt=ServerlessInAWS></p>
<p>在这个架构中，我们采用了前后端分离的技术。我们把 HTML，JS， CSS 等静态内容部署在 S3 上，并通过 CloudFront 作为 CDN 构成了整个架构的前端部分。我们把 Amazon API Gateway 作为后端的整体接口连接后端的各种风格的微服务，无论是运行在 Lambda 上的函数，还是运行在 EC2 上的 Java 微服务，他们整体构成了这个应用的后端部分。</p>
<p>从这个架构图上我们可以明显的看到 前端（Frontend）和后端（Backend）的区分。</p>
<h2 id=持续部署流水线的设计和实现>持续部署流水线的设计和实现 <a class=heading-anchor href=#%e6%8c%81%e7%bb%ad%e9%83%a8%e7%bd%b2%e6%b5%81%e6%b0%b4%e7%ba%bf%e7%9a%84%e8%ae%be%e8%ae%a1%e5%92%8c%e5%ae%9e%e7%8e%b0 aria-label=锚点>#</a></h2>
<p>任何 DevOps 部署流水线都可以分为三个阶段：待测试，待发布，已发布。</p>
<p>由于我们的架构是前后端分离的，因此我们为前端和后端分别构造了两条流水线，使得前后端开发可以独立。如下图所示：</p>
<p><img src=/img/post/20180201/full-pipeline.png alt=full-pipeline></p>
<p>在这种情况下，前端团队和后端团队是两个不同的团队，可以独立开发和部署，但在发布的时候则有些不同。由于用户是最后感知功能变化的。因此，为了避免界面报错找不到接口，在新增功能的场景下，后端先发布，前端后发布。在删除功能的场景下，前端先发布，后端后发布。</p>
<p>我们采用 Jenkins 构建我们的流水线，Jenkins 中已经含有足够的 AWS 插件可以帮助我们完成整个端到端的持续交付流水线。</p>
<h3 id=前端流水线>前端流水线 <a class=heading-anchor href=#%e5%89%8d%e7%ab%af%e6%b5%81%e6%b0%b4%e7%ba%bf aria-label=锚点>#</a></h3>
<p>前端持续交付流水线如下所示：</p>
<p><img src=/img/post/20180201/frontend-pipeline.png alt=frontend-pipeline></p>
<p>前端流水线的各步骤过程如下：</p>
<ol>
<li>我们采用 BDD/ATDD 的方式进行前端开发。用 NightWatch.JS 框架做 端到端的测试，mocha 和 chai 用于做某些逻辑的验证。</li>
<li>我们采用单代码库主干（develop 分支）进行开发，用 master 分支作为生产环境的部署。生产环境的发布则是通过 Pull Request 合并的。在合并前，我们会合并提交。</li>
<li>前端采用 Webpack 进行构建，形成前端的交付产物。在构建之前，先进行一次全局测试。</li>
<li>由于 S3 不光可以作为对象存储服务，也可以作为一个高可用、高性能而且成本低廉的静态 Web 服务器。所以我们的前端静态内容存储在 S3 上。每一次部署都会在 S3 上以 build 号形成一个新的目录，然后把 Webpack 构建出来的文件存储进去。</li>
<li>我们采用 Cloudfront 作为 CDN，这样可以和 S3 相互集成。只需要把 S3 作为 CDN 的源，在发布时修改对应发布的目录就可以了。</li>
</ol>
<p>由于我们做到了前后端分离。因此前端的数据和业务请求会通过 Ajax 的方式请求后端的 Rest API，而这个 Rest API 是由 Amazon API Gateway 通过 Swagger 配置生成的。前端只需要知道 这个 API Gateway，而无需知道API Gateway 的对应实现。</p>
<h3 id=后端流水线>后端流水线 <a class=heading-anchor href=#%e5%90%8e%e7%ab%af%e6%b5%81%e6%b0%b4%e7%ba%bf aria-label=锚点>#</a></h3>
<p>后端持续交付流水线如下所示：</p>
<p><img src=/img/post/20180201/backend-pipeline.png alt=frontend-pipeline></p>
<p>后端流水线的各步骤过程如下：</p>
<ol>
<li>我们采用“消费者驱动的契约测试”进行开发，先根据前端的 API 调用构建出相应的 Swagger API 规范文件和示例数据。然后，把这个规范上传至 AWS API Gateway，AWS API Gateway 会根据这个文件生成对应的 REST API。前端的小伙伴就可以依据这个进行开发了。</li>
<li>之后我们再根据数据的规范和要求编写后端的 Lambda 函数。我们采用 NodeJS 作为 Lambda 函数的开发语言。并采用 Jest 作为 Lambda 的 TDD 测试框架。</li>
<li>和前端一样，对于后端我们也采用单代码库主干（develop 分支）进行开发，用 master 分支作为生产环境的部署。</li>
<li>由于 AWS Lambda 函数需要打包到 S3 上才能进行部署，所以我们先把对应的构建产物存储在 S3 上，然后再部署 Lambda 函数。</li>
<li>我们采用版本化 Lambda 部署，部署后 Lambda 函数不会覆盖已有的函数，而是生成新版本的函数。然后通过别名（Alias）区分不同前端所对应的函数版本。默认的 $LATEST，表示最新部署的函数。此外我们还创建了 Prod，PreProd, uat 三个别名，用于区分不同的环境。这三个别名分别指向函数某一个发布版本。例如：函数 func 我部署了4次，那么 func 就有 4个版本（从1开始）。然后，函数 func 的 $LATEST 别名指向 4 版本。别名 PreProd 和 UAT 指向 3 版本，别名 Prod 在 2 版本。</li>
<li>技术而 API 的部署则是修改 API Gateway 的配置，使其绑定到对应版本的函数上去。由于 API Gateway 支持多阶段（Stage）的配置，我们可以采用和别名匹配的阶段绑定不同的函数。</li>
<li>完成了 API Gateway 和 Lamdba 的绑定之后，还需要进行一轮端到端的测试以保证 API 输入输出正确。</li>
<li>测试完毕后，再修改 API Gateway 的生产环境配置就可以了。</li>
</ol>
<p>部署的效果如下所示：</p>
<p><img src=/img/post/20180201/lambda-deployment.png alt=lambda-deployment></p>
<h2 id=无服务器微服务的持续交付新挑战>无服务器微服务的持续交付新挑战 <a class=heading-anchor href=#%e6%97%a0%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%be%ae%e6%9c%8d%e5%8a%a1%e7%9a%84%e6%8c%81%e7%bb%ad%e4%ba%a4%e4%bb%98%e6%96%b0%e6%8c%91%e6%88%98 aria-label=锚点>#</a></h2>
<p>在实现以上的持续交付流水线的时候，我们踩了很多坑。但经过我们的反思，我们发现是云计算颠覆了我们很多的认识，当云计算把某些成本降低到趋近于 0 时。我们发现了以下几个新的挑战：</p>
<ol>
<li>如果你要 Stub，有可能你走错了路。</li>
<li>测试金子塔的倒置。</li>
<li>你不再需要多个运行环境，你需要一个多阶段的生产环境 (Multi-Stage Production)。</li>
<li>函数的管理和 NanoService 反模式。</li>
</ol>
<h3 id=stub-别逗了>Stub ？别逗了 <a class=heading-anchor href=#stub-%e5%88%ab%e9%80%97%e4%ba%86 aria-label=锚点>#</a></h3>
<p>很多开发者最初都想在本地建立一套开发环境。由于 AWS 多半是通过 API 或者 CloudFormation 操作，因此开发者在本地开发的时候对于AWS 的外部依赖进行打桩（Stub） 进行测试，例如集成DynamoDB（一种 NoSQL 数据库），当然你也可以运行本地版的 DynamoDB，但组织自动化测试的额外代价极高。然而随着微服务和函数规模的增加，这种管理打桩和构造打桩的虚拟云资源的代价会越来越大，但收效却没有提升。另一方面，往往需要修改几行代码立即生效的事情，却要执行很长时间的测试和部署流程，这个性价比并不是很高。</p>
<p>这时我们意识到一件事：<strong>如果某一个环节代价过大，你需要思考一下这个环节存在的必要性</strong>。</p>
<p>由于 AWS 提供了很好的配置隔离机制，于是为了得到更快速的反馈，我们放弃了 Stub 或构建本地 DynamoDB，而是直接部署在 AWS 上进行集成测试。只在本地执行单元测试，由于单元测试是 NodeJS 的函数，所以非常好测试。</p>
<p>另外一方面，我们发现了一个有趣的事实，那就是：</p>
<h3 id=测试金子塔的倒置>测试金子塔的倒置 <a class=heading-anchor href=#%e6%b5%8b%e8%af%95%e9%87%91%e5%ad%90%e5%a1%94%e7%9a%84%e5%80%92%e7%bd%ae aria-label=锚点>#</a></h3>
<p>由于我们采用 ATDD 进行开发，然后不断向下进行分解。在统计最后的测试代码和测试工作量的的时候，我们有了很有趣的发现：</p>
<p>End-2-End （UI）的测试代码占30%左右，占用了开发人员 30% 的时间（以小时作为单位）开发和测试。</p>
<p>集成测试（函数、服务和 API Gateway 的集成）代码占 45%左右，占用了开发人员60% 的时间（以小时作为单位）开发和测试。</p>
<p>单元测试的测试代码占 25%左右，占用了10%左右的时间开发和测试。</p>
<p>一开始我们以为我们走入了<a href=http://www.51testing.com/html/57/n-3714757.html>”蛋筒冰激凌反模式“或者”纸杯蛋糕反模式“</a>但实际上：</p>
<ol>
<li>我们并没有太多的手动测试，绝大部分自动化。除了验证手机端的部署以外，几乎没有手工测试工作量。</li>
<li>我们的自动化测试都是必要的，且没有重复。</li>
<li>我们的单元测试足够，且不需要增加单元测试。</li>
</ol>
<p>但为什么会造成这样的结果呢，经过我们分析。是由于 AWS 供了很多功能组件，而这些组件你无需在单元测试中验证（减少了很多 Stub 或者 Mock），只有通过集成测试的方式才能进行验证。因此，**Serverless 基础设施大大降低了单元测试的投入，但把这些不同的组件组合起来则劳时费力。**如果你有多套不一致的环境，那你的持续交付流水线配置则是很困难的。因此我们意识到：</p>
<h3 id=你不再需要多个运行环境你只需要一个多阶段的生产环境-multi-stage-production>你不再需要多个运行环境，你只需要一个多阶段的生产环境 (Multi-Stage Production) <a class=heading-anchor href=#%e4%bd%a0%e4%b8%8d%e5%86%8d%e9%9c%80%e8%a6%81%e5%a4%9a%e4%b8%aa%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83%e4%bd%a0%e5%8f%aa%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e5%a4%9a%e9%98%b6%e6%ae%b5%e7%9a%84%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83-multi-stage-production aria-label=锚点>#</a></h3>
<p>通常情况下，我们会有多个运行环境，分别面对不同的人群：</p>
<ol>
<li>面向开发者的本地开发环境</li>
<li>面向测试者的集成环境或测试环境（Test，QA 或 SIT）</li>
<li>面向业务部门的测试环境（UAT 环境）</li>
<li>面向最终用户的生产环境（Production 环境）</li>
</ol>
<p>然而多个环境带来的最大问题是环境基础配置的不一致性。加之应用部署的不一致性。带来了很多不可重现问题。在 DevOps 运动，特别是基础设施即代码实践的推广下，这一问题得到了暂时的缓解。然而<strong>无服务器架构则把基础设施即代码推向了极致：只要能做到配置隔离和部署权限隔离，资源也可以做到同样的隔离效果。</strong></p>
<p>我们通过 DNS 配置指向了同一个的 API Gateway，这个 API Gateway 有着不同的 Stage：我们只有开发（Dev）和生产（Prod）两套配置，只需修改配置以及对应 API 所指向的函数版本就可完成部署和发布。</p>
<p>然而，多个函数的多版本管理增加了操作复杂性和配置性，使得整个持续交付流水线多了很多认为操作导致持续交付并不高效。于是我们在思考</p>
<h3 id=对函数的管理和-nanoservices-反模式->对函数的管理和” NanoServices 反模式 “ <a class=heading-anchor href=#%e5%af%b9%e5%87%bd%e6%95%b0%e7%9a%84%e7%ae%a1%e7%90%86%e5%92%8c-nanoservices-%e5%8f%8d%e6%a8%a1%e5%bc%8f- aria-label=锚点>#</a></h3>
<p>根据微服务的定义，AWS API Gateway 和 Lambda 的组合确实满足 微服务的特征，这看起来很美好。就像下图一样：</p>
<p><img src=/images/post/20180201/faas.png alt=faas></p>
<p>但当Lambda 函数多了，管理众多的函数的发布就成为了很高的一件事。而且， 可能会变成<a href=https://www.infoq.com/news/2014/05/nano-services>” NanoService 反模式“</a></p>
<blockquote>
<p>Nanoservice is an antipattern where a service is too fine-grained. A nanoservice is a service whose overhead (communications, maintenance, and so on) outweighs its utility.</p>
</blockquote>
<p>如何把握微服务的粒度和函数的数量，就变成了一个新的问题。而 <a href=https://serverless.com/>Serverless Framework</a>，就是解决这样的问题的。它认为微服务是由一个多个函数和相关的资源所组成。因此，才满足了微服务可独立部署可独立服务的属性。它把微服务当做一个用于管理 Lambda 的单元。所有的 Lambda 要按照微服务的要求来组织。Serverless Framework 包含了三个部分：</p>
<ol>
<li>一个 CLI 工具，用于创建和部署微服务。</li>
<li>一个配置文件，用于管理和配置 AWS 微服务所需要的所有资源。</li>
<li>一套函数模板，用于让你快速启动微服务的开发。</li>
</ol>
<p>此外，这个工具由 AWS 自身推广，所以兼容性很好。但是，我们得到了 Serverless 的众多好处，却难以摆脱对 AWS 的依赖。因为 AWS 的这一套架构是和别的云平台不兼容的。</p>
<p>所以，这就又是一个“自由的代价”的问题。</p>
<h3 id=cloudnative-的持续交付>CloudNative 的持续交付 <a class=heading-anchor href=#cloudnative-%e7%9a%84%e6%8c%81%e7%bb%ad%e4%ba%a4%e4%bb%98 aria-label=锚点>#</a></h3>
<p>在实施 Serverless 的微服务期间，发生了一件我认为十分有意义的事情。我们客户想增加一个很小的需求。我和两个客户方的开发人员，客户的开发经理，以及客户业务部门的两个人要实现一个需求。当时我们 6 个人在会议室里面讨论了两个小时。讨论两个小时之后我们不光和业务部门定下来了需求（这点多么不容易），与此同时我们的前后端代码已经写完了，而且发布到了生产环境并通过了业务部门的测试。由于客户内部流程的关系，我们仅需要一个生产环境发布的批准，就可以完成新需求的对外发布！</p>
<p>在这个过程中，由于我们没有太多的环境要准备，并且和业务部门共同制定了验收标准并完成了自动化测试的编写。这全得益于 Serverless 相关技术带来的便利性。</p>
<p>我相信在未来的环境，如果这个架构，如果在线 IDE 技术成熟的话（由于 Lambda 控制了代码的规模，因此在线 IDE 足够），那我们可以大量缩短我们需求确定之后到我功能上线的整体时间。</p>
<p>通过以上的经历，我发现了 CloudNative 持续交付的几个重点：</p>
<ol>
<li>优先采用 SaaS 化的服务而不是自己搭建持续交付流水线。</li>
<li>开发是离不开基础设施配置工作的。</li>
<li>状态和过程分离，把状态通过版本化的方式保存到配置管理工具中。</li>
</ol>
<p>而在这种环境下，Ops工作就只剩下三件事：</p>
<ol>
<li>设计整体的架构，除了基础设施的架构以外，还要关注应用架构。以及优先采用的 SaaS 服务解决问题。</li>
<li>严格管理配置和权限并构建一个快速交付的持续交付流程。</li>
<li>监控生产环境。</li>
</ol>
<p>剩下的事情，就全部交给云平台去做。</p>
</section>
<footer class=pt-8>
<div class=flex>
<img class="w-24 h-24 !mt-0 !mb-0 mr-4 rounded-full" src=/img/author.jpg>
<div class=place-self-center>
<div class="text-[0.6rem] leading-3 text-neutral-400 dark:text-neutral-500 uppercase">
作者
</div>
<div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
顾宇
</div>
<div class="text-sm text-neutral-700 dark:text-neutral-400">Stand Alone CompleX</div>
<div class="flex flex-wrap text-neutral-400 dark:text-neutral-500">
<a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://linkedin.com/in/wizardbyron target=_blank alt=Linkedin rel="me noopener noreferrer">
<span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg>
</span>
</a>
<a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://github.com/wizardbyron target=_blank alt=Github rel="me noopener noreferrer">
<span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span>
</a>
</div>
</div>
</div>
<div class="pt-8 article-pagination">
<hr class="border-dotted border-neutral-300 dark:border-neutral-600">
<div class="flex justify-between pt-3">
<span>
<a class=flex href=/posts/2018-03-01-principlesofchaos-zh-cn/>
<span class="mr-3 article-pagination-direction">&larr;</span>
<span class="flex flex-col">
<span class="article-pagination-title mt-[0.1rem] leading-6">翻译-混沌工程的原则</span>
<span class="mt-[0.1rem] text-xs text-neutral-400 dark:text-neutral-500">
<time datetime="2018-03-01 00:00:00 +0000 UTC">1 March 2018</time>
</span>
</span>
</a>
</span>
<span>
<a class="flex text-right" href=/posts/2017-12-07-devops-trends-in-tech-radar/>
<span class="flex flex-col">
<span class="article-pagination-title mt-[0.1rem] leading-6">从最新一期技术雷达看 DevOps 的发展</span>
<span class="mt-[0.1rem] text-xs text-neutral-400 dark:text-neutral-500">
<time datetime="2017-12-07 00:00:00 +0000 UTC">7 December 2017</time>
</span>
</span>
<span class="ml-3 article-pagination-direction">&rarr;</span>
</a>
</span>
</div>
</div>
</footer>
</article>
</main><footer class=py-10>
<div class="flex justify-between">
<div>
<p class="text-sm text-neutral-400 dark:text-neutral-500">
&copy;
2021
顾宇
</p>
<p class="text-xs text-neutral-300 dark:text-neutral-600">
由 <a class="hover:underline hover:underline-primary-300 hover:text-primary-400" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:underline-primary-300 hover:text-primary-400" href=https://git.io/hugo-congo target=_blank rel="noopener noreferrer">Congo</a> 强力驱动
</p>
</div>
<div class="text-sm cursor-pointer text-neutral-400 dark:text-neutral-500">
<button id=dark-toggle onclick="setPreferredAppearance('dark')" oncontextmenu="return setPreferredAppearance('default'),!1" class="inline px-2 py-1 border rounded-md border-neutral-200 dark:hidden hover:text-primary-500 hover:border-primary-400" title=切换为深色模式>
<span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M283.211 512c78.962.0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954.0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156.0 00283.211.0c-141.309.0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg>
</span>
</button>
<button id=light-toggle onclick="setPreferredAppearance('light')" oncontextmenu="return setPreferredAppearance('default'),!1" class="hidden px-2 py-1 border rounded-md cursor-pointer dark:inline border-neutral-700 hover:text-primary-400 hover:border-primary-500" title=切换为浅色模式>
<span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 160c-52.9.0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6.0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0s-49.9-131.1.0-181 131.1-49.9 181 0 49.9 131.1.0 181z"/></svg>
</span>
</button>
</div>
</div>
</footer>
</body>
</html>