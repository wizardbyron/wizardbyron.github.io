---
title: "【翻译】作为演进式架构的微服务架构"
date: 2022-04-10
tags:
- 翻译
- 微服务
- 演进式架构
---
> 原文:<https://www.thoughtworks.com/insights/blog/microservices-evolutionary-architecture>

微服务架构风格正在风靡全球。 去年 3 月（译注：2015年3月），O'Reilly 举办了第一次软件架构大会，委员会收到的大部分摘要都涉及微服务的某些方面。为什么这种架构风格突然风靡一时？

微服务是 DevOps 革命后的第一个架构风格，第一个完全接受持续交付的工程实践。它也是一个演进式架构的例子，作为应用程序架构中多个维度的第一原则：支持增量的非破坏性变更。 然而，它只支持某些演化行为的一类架构中的其中一种。 本文探讨了这一类架构风格的一些特点和原则。

## 演进式架构

软件中的常识曾认为架构元素“未来很难改变”。 演进式架构将架构中的增量变更设计作为首要原则。演进式架构之所以吸引人，是因为历史上的架构变更难以预测且改造成本高昂。如果将渐进式变更内置到架构中，变更将变得更容易、更便宜，从而允许开发实践、发布实践的变更以及整体的敏捷性。

微服务之所以符合这个定义，是因为其强大的限界上下文原则，使得 Evan 的领域驱动设计中描述的逻辑隔离原则成为物理隔离原则。微服务通过机器配置、测试和自动化部署等高级 DevOps 实践来实现这种隔离。因为每个服务都与所有其他服务（在结构级别）解耦，所以微服务的替换就像替换乐高积木。

## 演进式架构的特征

进化架构表现出几个共同的特征。 我们已经为即将出版的《演进式架构》一书（译注：人民邮电出版社已出版）中已经有了一些特征定义；本文将介绍其中的几种。

### 模块化和组合

如果开发人员想要进行非破坏性更改，沿着明确定义的边界分离组件的能力具有明显的益处。 没有任何架构性元素（比如通常说的的大泥球架构）就无法支持演进，因为它缺乏边界划分。

![大泥球架构](/img/blog/20220410/big_ball_of_mud.png)

上图来自某客户项目的大泥球中的类（周界上的点）之间的耦合。

不适当的组合会以难以预测的方式传播变化来抑制架构演进。 演进式架构都支持某种程度的模块化，通常表现在技术架构上（例如，经典的分层架构）。

### 围绕业务能力组织架构

受域驱动设计的启发，现代成功的架构也越来越多地在域架构级别具有模块化特征。基于服务（Service-based）的架构与传统 SOA 的主要区别在于分区策略：SOA 严格按照技术层次进行服务划分，而基于服务的架构则倾向于微服务的按领域划分。

### 实验

实验是向企业提供演进架构的强大驱动力。允许常见的持续交付实践对应用程序进行运维上细微的更改，如 A/B 测试、金丝雀发布等。 通常，微服务架构是围绕服务之间的路由设计的，用以定义应用程序，并允许特定服务的存在多个版本同时存在。这又反过来允许对现有功能进行实验和逐步替换。最终，这种能力能让你的企业用更少的时间来评估需求优先级，而直接通过假设驱动软件开发。

## 演进式架构的原则

思考演进式架构的一种方式是通过原则。这些原则描述了架构本身或设计架构的方法的各种特征。一些原则将注意力集中在设计架构过程中何时做出特定的架构决策。

### 适应度函数

我们区分新兴的架构和演进过的架构，这种区别很重要。就像在遗传算法等演化计算技术中一样，架构适应度函数指定了我们的目标架构的外观。一些系统需要较长的正常运行时间，而另一些则更关心吞吐量或安全性。

![适应度函数](/img/blog/20220410/fitness_function_fit.png)

上图是用于突出显示适用于该软件系统的重要适应度函数的雷达图。

首当其冲的问题是什么样的适应度函数应该为特定系统的提供决策指导。架构决策是相对于适应度函数进行评分的，因此我们可以看到架构是否正在朝着正确的方向演进。

### 负痛向前

受极限编程社区的启发，持续交付和进化架构中的许多实践都体现了“负痛向前”的原则。 当项目中的某些事情有可能导致痛苦时，强迫自己更早地更频繁去做这些事，这反过来又会鼓励你将痛苦自动化并及早发现问题。 常见的持续交付实践，如部署流水线、自动机器配置和数据库迁移，通过消除常见的变更痛点，使进化架构更容易。

### 最后的责任时刻

何时做架构决策是传统架构和演进架构之间的主要区别。这些决策可能围绕应用程序的结构、技术栈、特定工具或通信模式。在传统架构中，这些决策会在编写代码之前很早就体现出来。而在演进式架构中，我们等待最后一个负责任的时刻做出决定。延迟决策的好处是可获得可用于做出决策的额外信息。成本是一旦做出决定就必须发生的的返工，可以通过适当的抽象来减轻——但成本仍然是真实存在的。而过早做出决定的代价也是真实的。考虑选择消息传递工具。各种工具具有不同的支持功能。如果我们选择了一个比我们最终需要的更重的工具，它就会成为项目中技术债务的来源。这种债务以使用错误工具造成的演进负担的形式出现。这不是先发制人地“抽象所有事物”的借口——我们仍然支持敏捷中的 YAGNI（You aren't gonna need it，你不需要它）原则——而是在适当的时候做出决定的明智尝试。

当然，在考虑最后一个负责任的时刻时，最直接的问题是决定那个时刻是什么时候。适应度函数为决策提供指导。将其它对架构设计取舍产生重大影响的决策，或影响项目关键成功因素的决策应尽早做出。 推迟这样的决定对项目的影响往往大于等待的好处。

## 结论

软件架构师有责任阐明关于系统如何组合在一起的决策。通常是采用创建图表的方式。 太多的架构师没有意识到，静态的架构图保质期很短。软件行业是一个不断变化的领域；它是动态的而不是静态的。架构不是一个方程式，而是一个正在进行的过程的快照。

持续交付和 DevOps 运动说明了忽视实施架构并使其保持最新所需的努力的缺陷。对架构进行建模并捕捉这些努力并没有错，但这只是第一步。架构在可操作化之前是抽象的。 换句话说，你不能真正判断任何架构的长期可行性，除非你不仅实现并升级了家沟。甚至可能使它能够承受不寻常的事件。

架构师的运维意识对于演进式架构至关重要。演进会影响实现的细节，因此不能忽略实现细节。持续交付对架构的要求使实现更加可见并简化了其演进。 因此，持续交付是任何演进架构的重要推动力。
