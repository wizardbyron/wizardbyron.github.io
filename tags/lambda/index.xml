<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lambda on 顾宇的博客</title><link>https://wwww.guyu.me/tags/lambda/</link><description>Recent content in Lambda on 顾宇的博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 02 Jun 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://wwww.guyu.me/tags/lambda/index.xml" rel="self" type="application/rss+xml"/><item><title>云原生 DevOps</title><link>https://wwww.guyu.me/posts/2018-06-02-cloudnative-devops/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2018-06-02-cloudnative-devops/</guid><description>回头遥望，DevOps 将迎来自己的十岁生日。对于整个行业，这十年 DevOps给 IT 行业所带来的冲击并没有因为时间的增长而放慢革新的脚步，反而越发的剧烈和深远。
随着大规模的互联网应用不断在云计算平台上遇到挑战，新的应用架构模式呼之欲出，在众多的实践和方法论中，CloudNative 应用则是其中的佼佼者。 CloudNative 应用结合了 DevOps 社区在互联网上的最佳实践。
然而，仅仅有了构建 CloudNative 应用的方法论是不够的。一方面，没有采用 DevOps 从组织和流程的角度优化企业的流程，仍然会出现 “DevOps 之痛”，并阻碍着互联网转型。另一方面，“经典的”企业级 DevOps 同样面临着 CloudNative 带来的新挑战。于是我们可以看到，很多具有 DevOps 基因的互联网企业开始刻意的进行敏捷和 DevOps 转型。而率先完成 敏捷和 DevOps 的企业在进行 云原生 应用改造和技术革新上带来了新的问题。
这就对 DevOps 在云原生的环境下提出了新的课题和实践诉求，我们如何在云原生的环境下实践 DevOps 以达到更有生产力的表现？
本文将从最新一期的技术雷达中，试图勾画出 DevOps 在云原生的环境下的特性、未来的趋势以及相应的实践。
背景：不断蔓延的云环境复杂性 # 本期技术雷达主题之一是：不断蔓延的云环境复杂性。
随着更多的云计算厂商的诞生，差异性质的服务将会越来越少。而在马太效应下，云计算平台之间也将迎来大规模的整合和重组。云计算平台之间竞争不断加剧，使得我们对云计算有了更多的选择，然而带来的是云平台之间在兼容性上的问题。我们虽然可以看到 Docker 这样的封装式解决方案，但对于整体云计算平台的编排和利用。例如网络，安全设施，服务资源间调度，却统一规范和标准。从平台的角度来看，这确实是避免客户流失的有效手段。但留给用户的选择空间不大。
因此，跨云平台的基础设施编排工具不断出现，使得用户可以在不同的云平台之间无缝切换。随之而来的将是一个云计算的标准或者事实标准将呼之欲出，加强这个市场上的马太效应，淘汰掉小的云服务厂商，或者因为技术独特而被大的厂商收购。
如果你害怕自己的数据中心被平台所绑定，则需要花费更多的成本来维护一个云平台之间兼容性的应用系统。
SecDevOps # 本期技术雷达的另一个主题之一是：信任但要验证。
相对于企业级的可控网络和访问结点来说，在云原生的环境下，企业所面临的挑战则更为艰巨。这就好比你之前在自己小区的花丛里种花，你所面对的无非家猫家狗和小孩子的破坏。然后，你现在要在野生山林里种花，就要面对更加未知和复杂的环境。
然而，适应了企业级的应用开发和维护的开发团队并不如天生的互联网企业那般很快就能适应互联网的大丛林。
在 DevOps 运动刚开始的时候，安全并不是一个主要的 Topic，只是一系列需要注意的事项，于是在做 DevOps 实践的时候，把安全放在了最后考虑，即 DevOpsSec。随着 DevOps 的实践越来越激进，新的工具不断从社区涌现。安全作为 DevOps 的阻力则越来越大。但安全始终是绕不开的重要事情。因此，DevOps 社区尝试用同样的办法炮制和安全部门的合作以及安全实践，随后有了 DevSecOps，Sec 逐渐成为了 DevOps 实践中重要的一环。
就像我们之前讲的，面对复杂多变的云环境，安全要作为第一考量首先考量，而不是事后弥补。这一点就和我们在持续交付中探讨的“质量內建”一样。在云平台上实践 DevOps 要做到“安全內建”（Build Security In），这不单单是说我们增加几个自动化安全扫描的工具就足够的。要从系统的角度来重新思考安全在整个应用生命周期和团队的实践。ThoughtWorks 的安全社区在&amp;quot;安全內建&amp;quot;总结出了自己的实践，详细内容可以参考 buildsecurityin 网站。</description></item><item><title>Serverless 风格的微服务的持续交付</title><link>https://wwww.guyu.me/posts/2018-02-01-serverless-continurous-delivery/</link><pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2018-02-01-serverless-continurous-delivery/</guid><description>“Serverless 风格微服务的持续交付（上）：架构案例”中，我们介绍了一个无服务器风格的微服务的架构案例。这个案例中混合了各种风格的微服务
架构图如下：
在这个架构中，我们采用了前后端分离的技术。我们把 HTML，JS， CSS 等静态内容部署在 S3 上，并通过 CloudFront 作为 CDN 构成了整个架构的前端部分。我们把 Amazon API Gateway 作为后端的整体接口连接后端的各种风格的微服务，无论是运行在 Lambda 上的函数，还是运行在 EC2 上的 Java 微服务，他们整体构成了这个应用的后端部分。
从这个架构图上我们可以明显的看到 前端（Frontend）和后端（Backend）的区分。
持续部署流水线的设计和实现 # 任何 DevOps 部署流水线都可以分为三个阶段：待测试，待发布，已发布。
由于我们的架构是前后端分离的，因此我们为前端和后端分别构造了两条流水线，使得前后端开发可以独立。如下图所示：
在这种情况下，前端团队和后端团队是两个不同的团队，可以独立开发和部署，但在发布的时候则有些不同。由于用户是最后感知功能变化的。因此，为了避免界面报错找不到接口，在新增功能的场景下，后端先发布，前端后发布。在删除功能的场景下，前端先发布，后端后发布。
我们采用 Jenkins 构建我们的流水线，Jenkins 中已经含有足够的 AWS 插件可以帮助我们完成整个端到端的持续交付流水线。
前端流水线 # 前端持续交付流水线如下所示：
前端流水线的各步骤过程如下：
我们采用 BDD/ATDD 的方式进行前端开发。用 NightWatch.JS 框架做 端到端的测试，mocha 和 chai 用于做某些逻辑的验证。 我们采用单代码库主干（develop 分支）进行开发，用 master 分支作为生产环境的部署。生产环境的发布则是通过 Pull Request 合并的。在合并前，我们会合并提交。 前端采用 Webpack 进行构建，形成前端的交付产物。在构建之前，先进行一次全局测试。 由于 S3 不光可以作为对象存储服务，也可以作为一个高可用、高性能而且成本低廉的静态 Web 服务器。所以我们的前端静态内容存储在 S3 上。每一次部署都会在 S3 上以 build 号形成一个新的目录，然后把 Webpack 构建出来的文件存储进去。 我们采用 Cloudfront 作为 CDN，这样可以和 S3 相互集成。只需要把 S3 作为 CDN 的源，在发布时修改对应发布的目录就可以了。 由于我们做到了前后端分离。因此前端的数据和业务请求会通过 Ajax 的方式请求后端的 Rest API，而这个 Rest API 是由 Amazon API Gateway 通过 Swagger 配置生成的。前端只需要知道 这个 API Gateway，而无需知道API Gateway 的对应实现。</description></item><item><title>Serverless 风格的微服务的架构案例</title><link>https://wwww.guyu.me/posts/2017-09-21-serverless-architecture-sample/</link><pubDate>Thu, 21 Sep 2017 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2017-09-21-serverless-architecture-sample/</guid><description>Serverless 架构最早可以追溯到 Ken Fromm 发表的文章《Why The Future Of Software And Apps Is Serverless》。在这篇文章里， Ken Fromm 描述了在未来云计算基础设施普及的情况下。在构建应用程序的时候，开发人员和运维人员无需担心服务器如何安装配置，如何设置网络和负载均衡，无需监控状态，甚至不再会出现服务器相关的工作内容。这样可以让原本建设机房的时间成本和货币成本从按年计算缩短至按秒计算。
在 Martin Fowler 的博客《Serverless Architectures》中，他将无服务器架构分为两种：
第一种无服务器架构被称为被称为 BaaS（Backend as a Service，后端应用即服务）。即应用的架构是由一大堆第三方 API 来组织的。一切状态和逻辑都由这些服务提供方来管理。随着移动应用和单页 Web 应用这样的富客户端（Rich Client）应用的普及，前后端的通信渐渐以 API 调用为主，而所需的服务不再由 服务端应用开发工程师和运维工程师来维护，只需要调用提供服务的第三方 API 就可以完成相应的功能。例如云上的数据库服务和用户认证服务。
另一种无服务器架构被称为 FaaS（Function as a Service，函数即服务)。这一架构的兴起源于 AWS Lambda 的发展。 AWS Lambda 是一种无状态的代码运行时服务，这项服务提供最小的代码运行资源。你可以使用 Java，Node.js，Python 和 C# 编写程序处理 AWS 各种服务的事件。无需初始化一台服务器，安装操作系统并配置程序运行环境。由于运行资源很少，完成的计算有限，使得这种应用无法保存状态，因此这类程序以函数的方式存在。
本文所介绍的 Serverless 架构主要是以 AWS Lambda 以及 Amazon API Gateway 架构的应用，它同时也具备 BaaS 的特征。
AWS Lambda 的编程模型 # AWS Lambda 的编程模型如下所示：</description></item></channel></rss>