<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>持续交付 on 顾宇的博客</title><link>https://wwww.guyu.me/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/</link><description>Recent content in 持续交付 on 顾宇的博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 10 May 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://wwww.guyu.me/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/index.xml" rel="self" type="application/rss+xml"/><item><title>从星巴克店面运营学习 DevOps</title><link>https://wwww.guyu.me/posts/2019-05-10-how-starbucks-play-devops/</link><pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2019-05-10-how-starbucks-play-devops/</guid><description>某次在星巴克等咖啡的时候，闲来无事开始观察店员的的工作。可能是出于职业习惯，我开始观察和分析星巴克的工作流程。突然发现星巴克的咖啡交付过程很像一个敏捷软件开发团队的交付过程。后来通过进一步观察和细聊，发现星巴克的店面运营是一个 DevOps 运作的榜样。
如果我们把星巴克的店员们看做是一个开发/运维团队，把咖啡的交付看作软件的交付，把店面的基础设施维护和清洁看作是运维工作。我们就发现了一个很好的 DevOps 学习榜样。
让我们看看星巴克店面是如何做 DevOps 的。
星巴克咖啡交付团队的角色组成 # 在星巴克里，大家都相互称对方为星伙伴。我个人理解是通过弱化职级称谓提升每个人的责任心。所有的店员分为四个角色：
店面主管（SS或IC）：负责店面整体的管理。
收银：负责点单、推荐产品和收款。
吧台：负责制作饮品。
CS：负责门店补货，清理桌面。
店面主管主要负责团队的任务安排，你可以把它当做是 PM 或者 Scrum Master。在一切都井然有序的情况下，他的工作和一般的员工是一样的。只要他发现了临时需要处理的情况，他才会根据店面的资源来安排临时性的工作。
吧台内部分为三个部分：收银点单区、咖啡制作区、咖啡待取区，如下图所示：
收银点单区的店员根据客人的需求点单，然后记录到咖啡杯上。
咖啡制作区的店员会根据杯子上的标记制作饮品。
制作完成后的咖啡会放到咖啡待取区等客人来取。
所有的店员都具备所有的技能（全栈工程师），并通过标准化的考试上岗。你会看到在星巴克里有绿色围裙和黑色围裙。黑色围裙的咖啡师是经过考试的，考试合格后会发黑色围裙作为通过认证的标志。
反思：你的工程师有标准化的技能考试吗？
星巴克咖啡交付团队的 DevOps 单向工作流 # 说到 DevOps，不能不提到&amp;quot;三步工作法&amp;quot;。首先，我们要用到第一步——构建端到端单向工作流——来观察星巴克店面是如何构建单向工作流的。
我们可以把交付一杯咖啡的流程和软件开发的交付一个用户故事的流程的关系做如下对应：
需求分析：和客人交流并记录客人对咖啡的需求。
产品开发：按照需求制作咖啡。
产品发布：制作完成并通知客人取咖啡。
基础设施运维：咖啡店面的日常清扫和补货。
在这个基础上，我们看看一杯咖啡从点单开始，星巴克的持续交付流水线就是它设备的摆放顺序，确保杯子的单一方向流动，避免返工和逆向流动。
点单：虽然星巴克的咖啡是流水化工业制品。但是也是存在定制的，比如类别、口味、冷热、大小。虽然顾客有需求，但需求控制在一定范围之内(哪些做得到，哪些做不到)并且通过产品价位板告知顾客。
反思：你的团队能做什么，不能做什么，什么时候做完，你是否对交付成果有信心？这些信心来自哪里？如果没有信心，如何获得信心？
标记：在点单阶段，收银会把客户的每一个需求记录到杯子上，包括顾客的姓名。星巴克咖啡采取的是“预付费”(先付费再生产)而非“后付费”（先生产再买单）的方式。这些记录是对一杯咖啡需求验收标准的分解。通过杯子大小来控制每个需求点的验收和用量。
反思：你的团队开发需求时是否把每个验收条件记录下来并且在不同的阶段控制质量和用时？
制作：每个带着记号的咖啡杯就是一个格式化的需求文档。上面详细的记录了这个顾客的需求，并且这些需求可以验证。每杯咖啡都有标准的验收样例和工序，所以每个店员都知道完成的标准是什么。这样，即便不是点单的店员，看到杯子上的记号，也能做出符合顾客验收条件的咖啡。此外，每个杯子上都会有顾客姓名的标记，以免点错单。
反思：你的团队需求文档中的信息是否可以做到无解释交接？
出品：星巴克“完成”的定义是“顾客拿到了咖啡”，而不是“咖啡制作完毕”。如果顾客没有确认拿到的咖啡符合需求，是没有完成的。如果顾客对咖啡不满意，是可以要求重做的。这时候，会由专门的店员负责重新制作咖啡，直到顾客满意为止。
反思：你的软件开发流程中“完成”的定义是开发完成？测试完成？还是上线发布完成？
制作区运营：星巴克从点单开始，到制作咖啡过程中所有的设备、物料、卫生等都要每天维护使之保持最佳使用状态。这些基础设施的使用都是高可用且可以按需伸缩的：两个收银机、两台咖啡机——如果一台坏了，有另外一台备份。默认情况下只使用一台，如果到了忙时两台才会同时使用。这一切都要通过星巴克店面的看板信号机制来动态协调。
反思：你的软件交付基础设施和人员是否具备动态协调的能力？为什么？
星巴克咖啡交付的看板系统 # 当我们构建了单向的价值流之后，来看看星巴克是如何应用 DevOps 第二工作法——构建快速反馈的。
首先，从上述流程中，我们可以看到星巴克的四个积压队列(Backlog)，分别是：点单队列、待制咖啡队列、制作中咖啡队列、待取咖啡队列。
这四个队列构成了星巴克咖啡交付的看板系统，每个环节都是一个单独的队列，并且通过不同的看板可视化积压情况。
点单队列 # 如果你正在点单，收银员会在你犹豫的时候帮你推荐。然后它会记下你姓名，咖啡的类别和定制化的要求。并记录在杯子上，放到待做咖啡队列。
一般星巴克的店面都会有两个收银台。平常的情况下只有一名星伙伴收银。如果有客户在收银机排队，就是需求分析资源不足的信号，收银台需要补人。收银台补人的原则是把两个人看作一个单位，如果超出了 2.5 个单位。收银台需要再补充另外一个人。如果两个收银还是不够，值班主管会让一个伙伴拿着点单卡(如下图)提前记录客人需要。这样可以节约在收银台前的时候，客人选择和犹豫时耽误的时间。
这样就避免了点单队列（需求分析）的积压。
待做咖啡杯队列和饮品制作流水线 # 此时待做咖啡队列就是一个个打上标记的空杯子。当空杯子数量超过5个，吧台里就需要有第二个人参与咖啡的制作，以减少待做队列里的积压。
简单的说，一杯标准的意式咖啡会包括三个环节：
制作浓缩咖啡(Espresso)。 制作奶沫。 混合并添加糖浆/冰块等配料。 在这三步中，第一步制作浓缩咖啡是需要等待的，在这期间星伙伴可以选择同时做其它的咖啡、制作奶沫或者增加配料。所以，咖啡不是一杯一杯交付的，而是一批一批交付的。</description></item><item><title>【翻译】软件定义交付宣言</title><link>https://wwww.guyu.me/posts/2019-03-14-sdd-manifesto/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2019-03-14-sdd-manifesto/</guid><description>原文链接：https://github.com/sdd-manifesto/manifesto 中文链接：https://github.com/wizardbyron/manifesto
软件定义交付宣言（Software Defined Delivery Manifesto） # 我们认识到, 提供有用的软件塑造了我们的世界。我们认识到，代码是指定精确操作的最佳方式。我们认识到, 只有在交付代码时, 代码才会有用。
交付不是一个细节, 而是我们的工作。现在是将我们的核心技能应用到自己的工作中的时候了。现在是时候 工程化 我们的交付。我们在人类自身和计算机之间分配我们的工作: 人类用于决策, 而自动化用于任务。
交付不是一个细节，而是我们的工作。现在是应用我们的核心技术到我们工作中的时刻了。现在是工程化我们的交付。我们在我们自身和计算机之间区分我们的工作：人类为了决策，自动化为任务。
交付工作本质上是独特的。应用程序、组织、部署环境和团队的每个组合都有自己的上下文。我们认识到, 每个团队都需要理解这种独特性的交付和自动化。我们认识到, 虽然持续交付对于满足业务需求至关重要, 但自动化所有重复的任务非常重要。
我们加快自动化的速度与加快应用程序开发的方式相同: 使用现代体系结构和编程语言以及用于通用能力的框架、库和服务。
我们承认现有技术。这不是发明的工作, 而是表达的工作, 是及时和急需的方法的工作。
交付基础设施现在是可编程的, 所以我们将对其进行编程。
软件定义交付（Software Defined Delivery）是 # 核心： 交付是每个软件团队和组织的基本和战略能力。
一流的： 交付代码就是生产代码。 战略性： 决定团队和组织层面的政策;在代码中精确地实现它, 而无需辛劳。 演进： 随着我们的了解, 我们不断地改进我们的交付。 工程化的: 在可靠的、可测试的代码中。
现代软件架构: 事件驱动并可扩展。 现代编程语言: 逻辑最好在代码中指定, 而不是在图片或 GUI 中指定。脚本不会扩张。 基于模型: 由软件领域的模型支持, 包含对代码的理解。 可测试: 允许部署在生产前进行较短的交付周期以发现错误。 进步: 随时促进部署。提供对受众群体和环境进行有控制、选择性的更改。允许是渐进和深思熟虑的发布。 协作:
在人群中: 每个人都可以通过代码表达他们的专业知识, 以造福于每个人。 在软件中: 我们使用同类最佳的工具, 但我们对这些工具的组合是独一无二的。 在人群和软件中: 协作自动化增强了我们的感知, 并实现了我们的决策。它将信息和行动带到我们所处的位置, 并使自动化行为为我们所理解。通过代码, 我们区分团队的共享交付目标集和它们的实现。 加速:
通过自动化: 我们自动执行重复的任务, 以加快我们的工作, 避免错误。 通过复用: 开发人员、团队和组织之间共享通用功能。 可观察的: 常见的方法是观察和排除作为生产系统的交付过程中发生的情况。
跟踪: 观察系统中的活动并跟踪动作之间的关系。 调试: 与交付流程交互并审查。 指标: 从整个交付流程中的活动中派生指标。 作者：（按照姓名首字母排序）Kenny Bastani, Marc Holmes, Rod Johnson, Jessica Kerr, Mik Kersten, Russ Miles, Erin Schnabel, Matt Stine.</description></item><item><title>Serverless 风格的微服务的持续交付</title><link>https://wwww.guyu.me/posts/2018-02-01-serverless-continurous-delivery/</link><pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2018-02-01-serverless-continurous-delivery/</guid><description>“Serverless 风格微服务的持续交付（上）：架构案例”中，我们介绍了一个无服务器风格的微服务的架构案例。这个案例中混合了各种风格的微服务
架构图如下：
在这个架构中，我们采用了前后端分离的技术。我们把 HTML，JS， CSS 等静态内容部署在 S3 上，并通过 CloudFront 作为 CDN 构成了整个架构的前端部分。我们把 Amazon API Gateway 作为后端的整体接口连接后端的各种风格的微服务，无论是运行在 Lambda 上的函数，还是运行在 EC2 上的 Java 微服务，他们整体构成了这个应用的后端部分。
从这个架构图上我们可以明显的看到 前端（Frontend）和后端（Backend）的区分。
持续部署流水线的设计和实现 # 任何 DevOps 部署流水线都可以分为三个阶段：待测试，待发布，已发布。
由于我们的架构是前后端分离的，因此我们为前端和后端分别构造了两条流水线，使得前后端开发可以独立。如下图所示：
在这种情况下，前端团队和后端团队是两个不同的团队，可以独立开发和部署，但在发布的时候则有些不同。由于用户是最后感知功能变化的。因此，为了避免界面报错找不到接口，在新增功能的场景下，后端先发布，前端后发布。在删除功能的场景下，前端先发布，后端后发布。
我们采用 Jenkins 构建我们的流水线，Jenkins 中已经含有足够的 AWS 插件可以帮助我们完成整个端到端的持续交付流水线。
前端流水线 # 前端持续交付流水线如下所示：
前端流水线的各步骤过程如下：
我们采用 BDD/ATDD 的方式进行前端开发。用 NightWatch.JS 框架做 端到端的测试，mocha 和 chai 用于做某些逻辑的验证。 我们采用单代码库主干（develop 分支）进行开发，用 master 分支作为生产环境的部署。生产环境的发布则是通过 Pull Request 合并的。在合并前，我们会合并提交。 前端采用 Webpack 进行构建，形成前端的交付产物。在构建之前，先进行一次全局测试。 由于 S3 不光可以作为对象存储服务，也可以作为一个高可用、高性能而且成本低廉的静态 Web 服务器。所以我们的前端静态内容存储在 S3 上。每一次部署都会在 S3 上以 build 号形成一个新的目录，然后把 Webpack 构建出来的文件存储进去。 我们采用 Cloudfront 作为 CDN，这样可以和 S3 相互集成。只需要把 S3 作为 CDN 的源，在发布时修改对应发布的目录就可以了。 由于我们做到了前后端分离。因此前端的数据和业务请求会通过 Ajax 的方式请求后端的 Rest API，而这个 Rest API 是由 Amazon API Gateway 通过 Swagger 配置生成的。前端只需要知道 这个 API Gateway，而无需知道API Gateway 的对应实现。</description></item><item><title>关于 DevOps ，咱们聊的可能不是一回事</title><link>https://wwww.guyu.me/posts/2017-12-03-we-are-talking-different-devops/</link><pubDate>Sun, 03 Dec 2017 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2017-12-03-we-are-talking-different-devops/</guid><description>在过去的三年中，我作为 DevOps 的咨询师参与了很多企业的 DevOps 转型咨询以及技术实施，也在不同的社区活动中分享了自己在 DevOps 上的实践、理解和观点。
随着 DevOps 的盛行，我在很多场合和越来越多的人聊起 DevOps。也在不同的渠道听到了很多人在讲 DevOps。然而，讨论的背后，我发现每个人对 DevOps 所指并不是同一件事情，也由于各执一词导致不欢而散。
于是我通过 DevOpsDays 的官方网站整理所有 DevOps 的有关材料，随着学习和了解的不断增多，我也渐渐的对 DevOps 有了更进一步的认识。我把学到的材料经过整理后把陆续放在了简书上，形成了&amp;quot; DevOps 前世今生&amp;quot; 这个系列，这个系列还在不断补充新的材料。
含义越来越丰富的 DevOps # DevOps 至今都缺乏一个清晰和统一的认识。对于一场运动来说，这是一件好事，也同样是一件坏事。虽然 Patrick 曾经在自己的博客里一再提到自己对 DevOps 的&amp;quot;正确认识''，但社区似乎不以为然。
缺乏“官方定义”好处是人人都可以定义，因此没有一个人或者组织可以垄断 DevOps 定义权。所以每个人都自己可以参与到这一运动中去，不断为其增加新的概念、新的实践和新的工具。这会使 DevOps 社区不断的繁荣。
而坏处也很明显，对于 DevOps 的后来者 —— 那些没有参与进来的人，需要学习和理解的 DevOps 知识的广度和深度也越来越大。
以至于后来出现了这幅众所周知的“盲人摸象图”：
这幅图中包含了很多概念，但主要表现的意义 DevOps 是一系列概念的总和，任何一个单方面的定义只是 DevOps 的一个部分，而不是 DevOps 的整体，随着 DevOps 这个概念的不断膨胀，人们就更难理解 DevOps 了。
那么，你理解的 DevOps 是指的什么 # 在接触了各类客户和社区之后，我开始尝试理解每个人谈到 DevOps 的时候，他们分别指的是什么，以及所指内容背后的目标和动机。渐渐的，我把我所听到的 DevOps 概念分成如下四类，分别是：
DevOps 是一组技术/实践 DevOps 是一个角色 DevOps 是一种工作方式 DevOps 是一种组织结构 那么，我们分别来谈谈这四类 DevOps。
当 DevOps 是一组技术/实践 # 在工程师文化的组织里，对先进技术的渴望是最常见的学习动机。可以促进工程师用更有效率，更优雅的方式解决问题。而对于非工程师文化的组织，新的技术往往是提升其 KPI 的工具。以下是我听到 DevOps 的时候，经常触及的话题：
高频部署 持续交付 云计算/虚拟化技术 基础设施即代码 Docker 自动化运维 高频部署 # 曾经和某跨国著名银行的外汇交易产品的 IT 产品负责人交流 DevOps。对方很自豪的告诉我，他们产品每天的部署频率超过500次，我听了不以为然。因为，部署频率高不见得是件好事。于是我问了以下几个问题：</description></item><item><title>Serverless 风格的微服务的架构案例</title><link>https://wwww.guyu.me/posts/2017-09-21-serverless-architecture-sample/</link><pubDate>Thu, 21 Sep 2017 00:00:00 +0000</pubDate><guid>https://wwww.guyu.me/posts/2017-09-21-serverless-architecture-sample/</guid><description>Serverless 架构最早可以追溯到 Ken Fromm 发表的文章《Why The Future Of Software And Apps Is Serverless》。在这篇文章里， Ken Fromm 描述了在未来云计算基础设施普及的情况下。在构建应用程序的时候，开发人员和运维人员无需担心服务器如何安装配置，如何设置网络和负载均衡，无需监控状态，甚至不再会出现服务器相关的工作内容。这样可以让原本建设机房的时间成本和货币成本从按年计算缩短至按秒计算。
在 Martin Fowler 的博客《Serverless Architectures》中，他将无服务器架构分为两种：
第一种无服务器架构被称为被称为 BaaS（Backend as a Service，后端应用即服务）。即应用的架构是由一大堆第三方 API 来组织的。一切状态和逻辑都由这些服务提供方来管理。随着移动应用和单页 Web 应用这样的富客户端（Rich Client）应用的普及，前后端的通信渐渐以 API 调用为主，而所需的服务不再由 服务端应用开发工程师和运维工程师来维护，只需要调用提供服务的第三方 API 就可以完成相应的功能。例如云上的数据库服务和用户认证服务。
另一种无服务器架构被称为 FaaS（Function as a Service，函数即服务)。这一架构的兴起源于 AWS Lambda 的发展。 AWS Lambda 是一种无状态的代码运行时服务，这项服务提供最小的代码运行资源。你可以使用 Java，Node.js，Python 和 C# 编写程序处理 AWS 各种服务的事件。无需初始化一台服务器，安装操作系统并配置程序运行环境。由于运行资源很少，完成的计算有限，使得这种应用无法保存状态，因此这类程序以函数的方式存在。
本文所介绍的 Serverless 架构主要是以 AWS Lambda 以及 Amazon API Gateway 架构的应用，它同时也具备 BaaS 的特征。
AWS Lambda 的编程模型 # AWS Lambda 的编程模型如下所示：
AWS Lambda 运行在一个虚拟的容器里，但你无法配置这个容器。此外，这个虚拟的容器有一些[资源限制]，主要限制如下：
5 分钟（300 秒）的程序运行时间。 512 MB 的文件系统空间。（在 /tmp 目录下） 最大1536 MB 的内存。（最小 128 MB，以 64 MB 作为增量） 最多 1024 个文件描述符。 最大 1024 个内部线程。 Lambda 的执行流程：</description></item></channel></rss>